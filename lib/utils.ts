import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';
import { flagedWords } from './data';

// generated by shadcn
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// created by chatgpt
export function isBase64Image(imageData: string) {
  const base64Regex = /^data:image\/(png|jpe?g|gif|webp);base64,/;
  return base64Regex.test(imageData);
}

// created by chatgpt
export function formatDateString(dateString: string) {
  const options: Intl.DateTimeFormatOptions = {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  };

  const date = new Date(dateString);
  const formattedDate = date.toLocaleDateString(undefined, options);

  const time = date.toLocaleTimeString([], {
    hour: 'numeric',
    minute: '2-digit',
  });

  return `${time} - ${formattedDate}`;
}

// created by chatgpt
export function formatThreadCount(count: number): string {
  if (count === 0) {
    return 'No Threads';
  } else {
    const threadCount = count.toString().padStart(2, '0');
    const threadWord = count === 1 ? 'Thread' : 'Threads';
    return `${threadCount} ${threadWord}`;
  }
}

export const trendingWordByHashtag = (tweets: any) => {
  const trendingWordsObject: any = {};

  tweets.forEach((items: any, index: number) => {
    // Extract words from the tweet message
    const words = items.message.split(/\s+/);

    words.forEach((word: string) => {
      // Remove special characters and convert to lowercase for consistency
      const cleanedWord = word.replace(/[^\w\s]/gi, '').toLowerCase();
      if (cleanedWord !== '') {
        // If the word is already in the trendingWordsObject, add the tweet to its array
        if (trendingWordsObject[cleanedWord]) {
          trendingWordsObject[cleanedWord].tweets.push(index);
        } else {
          // If the word is not in the trendingWordsObject, create a new entry
          trendingWordsObject[cleanedWord] = {
            tweets: [index], // Array to store tweet indices containing the word
            count: 1, // Initialize the count to 1
          };
        }
      }
    });
  });

  // Convert the trendingWordsObject to an array of objects
  const trendingWordsArray = Object.entries(trendingWordsObject).map(
    ([word, data]: any) => ({
      word,
      tweets: data.tweets.map((tweetIndex: any) => tweets[tweetIndex]),
      count: data.tweets.length,
    })
  );

  return trendingWordsArray;
  // Sort the array of trending words in descending order by count
  trendingWordsArray.sort((a, b) => b.count - a.count);
};

export const wordorPhrase = (tweets: any) => {
  // Initialize an empty object to store words and phrases
  const wordMap: any = {};

  // Iterate through each tweet
  tweets.forEach((tweet: any, index: number) => {
    const words = tweet.message.split(/\s+/); // Split the message into words

    for (let i = 0; i < words.length; i++) {
      const word = words[i];

      const cleanedWord = word.replace(/[^\w\s]/gi, '').toLowerCase();
      if (cleanedWord !== '' && !cleanedWord.startsWith('#')) {
        // Create a one-word
        if (!wordMap[cleanedWord]) {
          wordMap[cleanedWord] = [];
        }
        if (!wordMap[cleanedWord].find((items: any) => items.id === tweet.id)) {
          wordMap[cleanedWord].push(tweet);
        }

        // Create a two-word phrase
        if (i < words.length - 1) {
          const twoWordPhrase = `${cleanedWord} ${words[i + 1]}`;
          if (!wordMap[twoWordPhrase]) {
            wordMap[twoWordPhrase] = [];
          }
          if (!wordMap[twoWordPhrase].includes(tweet.id)) {
            wordMap[twoWordPhrase].push(tweet);
          }
        }

        // // Create a three-word phrase
        // if (i < words.length - 2) {
        //   const threeWordPhrase = `${cleanedWord} ${words[i + 1]} ${
        //     words[i + 2]
        //   }`;
        //   if (!wordMap[threeWordPhrase]) {
        //     wordMap[threeWordPhrase] = [];
        //   }
        //   if (
        //     !wordMap[threeWordPhrase].includes(tweet._id ? tweet._id : tweet.id)
        //   ) {
        //     wordMap[threeWordPhrase].push(tweet);
        //   }
        // }
      }
    }
  });

  const WordMapArray = Object.entries(wordMap).map(
    ([wordOrphrase, data]: [string, any]) => {
      return {
        word: wordOrphrase,
        tweets: data,
        count: data.length,
        hashtag: false,
      };
    }
  );

  const flaggedWord = WordMapArray.filter(
    (items) => !flagedWords.includes(items.word)
  );
  // console.log({ WordMapArray, flaggedWord });
  return flaggedWord;
};

export function hashtag(tweetss: any) {
  // Initialize an empty object to store hashtags and associated tweets
  const hashtagObject: any = {};

  // Iterate through tweets and process hashtags
  tweetss.forEach((tweet: any) => {
    const words = tweet.message.split(' ');
    words.forEach((word: string) => {
      if (word.startsWith('#')) {
        // Extract the hashtag and add the tweet to its array
        const hashtag = word.slice(1); // Remove the '#' symbol
        if (!hashtagObject[hashtag]) {
          hashtagObject[hashtag] = [tweet];
        } else if (
          !hashtagObject[hashtag].includes(tweet._id ? tweet._id : tweet)
        ) {
          // Avoid duplicating tweets
          hashtagObject[hashtag].push(tweet);
        }
      }
    });
  });
  // Convert the trendingWordsSentencesObject to an array of objects
  const trendingWordsSentencesArray = Object.entries(hashtagObject).map(
    ([word, data]: any) => ({
      word,
      tweets: data,
      count: data.length,
      hashtag: true,
    })
  );

  // Filter only sentences that occurred in at least two tweets

  // const trendingWordsSentencesFiltered = trendingWordsSentencesArray.filter(
  //   (data) => data.count >= 2
  // );

  // Sort the array in descending order by the count of occurrences
  const trendingWordsSentencesFiltered = trendingWordsSentencesArray.sort(
    (a, b) => b.count - a.count
  );
  // console.log({ trendingWordsSentencesArray, trendingWordsSentencesFiltered });
  return trendingWordsSentencesFiltered;
  // Sort the array in descending order by the count of occurrences
  const sort = trendingWordsSentencesFiltered.sort((a, b) => b.count - a.count);
}
